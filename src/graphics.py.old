#graphics.py

import pygame
import math
import gui

from pygame.locals import *

font = pygame.font.Font("visitor1.ttf",10)
titleFont = pygame.font.Font("visitor1.ttf",12)
boldFont = pygame.font.Font("visitor1.ttf",10)
boldFont.set_italic(True)

def sortY(a):
	if int(a.getPos()[1])!=a.getPos()[1]:
		print type(a)
	return int(a.getPos()[1]+a.getHeight())

class ScaledScreen(object):
	def __init__(self,screen,actualResX,actualResY,smoothing=0):
		self.ScaledScreen=screen
		self.AResX=actualResX
		self.AResY=actualResY
		self.Screen=pygame.surface.Surface((320,240))
		self.smoothing=smoothing
		if self.smoothing==1:
			self.AResX=640
			self.AResY=480
	
	def update(self):
		if self.smoothing==0:
			pygame.transform.scale(self.Screen,(self.AResX,self.AResY),self.ScaledScreen)
		elif self.smoothing==1:
			pygame.transform.scale2x(self.Screen,self.ScaledScreen)
		elif self.smoothing==2:
			pygame.transform.smoothscale(self.Screen,(self.AResX,self.AResY),self.ScaledScreen)
	
	def fill(self,color,rect=None,special_flags=0):
		if rect!=None:
			if rect[0]<0:
				rect[2]-=abs(rect[0])
			if rect[1]<0:
				rect[3]-=abs(rect[1])
		self.Screen.fill(color,rect,special_flags)
	
	def blit(self,source,dest,area=None,special_flags=0):
		self.Screen.blit(source,dest,area,special_flags)
	



class TextObject(object):
	def __init__(self,text,pos,color=(255,255,255)):
		self.text = text
		self.color = color
		self.sprite = font.render(text,True,color)
		self.pos=pos
		self.layer=1
	
	def setText(self,text):
		self.text=text
	
	def setPos(self,pos):
		self.pos=pos
	
	def update(self,tick=None):
		self.sprite = font.render(self.text,True,self.color)
	
	def getPos(self):
		return self.pos
	
	def getSprite(self):
		return self.sprite
	
	def getHeight(self):
		return 240

class GraphicObject(object):
	def __init__(self,Animations,AnimationSpeed,State=0,Direction=0,Layer=0):
		self.animations = Animations
		self.animationSpeed = AnimationSpeed	#in seconds
		
		self.state = State
		self.direction = Direction	#0-N, 1-E, 2-S, 3-W
		self.frame = 0
		self.layer = Layer
		
		self.x = 0
		self.y = 0
		
	def setPos(self,pos):
		self.x=pos[0]
		self.y=pos[1]
	
	def getWidth(self):
		return self.getSprite().get_width()
	
	def getHeight(self):
		return self.getSprite().get_height()
	
	def getPos(self):
		return [self.x,self.y]
	
	def getX(self):
		return self.x
	
	def getY(self):
		return self.y
	
	def setState(self,state):
		self.state=state
		self.setFrame(0.0)
	
	def setDirection(self,direction):
		self.direction=direction
	
	def setFrame(self,frame):
		self.frame=frame
	
	def getSprite(self):
		return self.animations[self.state][self.direction][int(self.frame)]
	
	def getFrame(self):
		return self.frame
	
	def update(self,tick):
		self.frame+=(tick*1/self.animationSpeed[self.state])
		if self.frame>=len(self.animations[self.state][self.direction]):
			self.frame=0

class GraphicsEngine(object):
	def __init__(self,screen,isScaled=False):
		self.screen = screen
		self.isScaled = isScaled
		self.objects = []
		self.Player = None
		self.background = pygame.surface.Surface([0,0])
		self.cameraPos=[0,0]
		self.focus=None
	
	def addObject(self,Object):
		self.objects.append(Object)
	
	def clearObjects(self):
		self.objects = []
	
	def setPlayer(self,Player):
		self.Player = Player
	
	def setFocus(self,focus):
		self.focus = focus
	
	def loadLevel(self,level):
		self.background = pygame.image.load("Backgrounds/Images/"+level+".png").convert()
	
	def update(self,tick):
		self.screen.fill((0,0,0))
		
		if self.focus != None:
			if self.background.get_width()>320:
				offsetX = self.focus.getX()+(self.focus.getWidth()/2)-160
			else:
				offsetX = 0
			if self.background.get_height()>240:
				offsetY = self.focus.getY()+(self.focus.getHeight()/2)-120
			else:
				offsetY = 0
		else:
			offsetX=0
			offsetY=0
		
		for Object in self.objects:
			Object.update(tick)
		self.Player.update(tick)
		
		self.objects.append(self.Player)
		
		self.screen.blit(self.background,(self.cameraPos[0]-offsetX,self.cameraPos[1]-offsetY))
		for go in self.objects:
			if go.layer<0:
				self.screen.blit(go.getSprite(),(go.getPos()[0]-offsetX,go.getPos()[1]-offsetY))
		
		self.objects.sort(key=sortY,reverse=False)
		for go in self.objects:
			if go.layer==0:
				self.screen.blit(go.getSprite(),(go.getPos()[0]-offsetX,go.getPos()[1]-offsetY))
		
		for go in self.objects:
			if go.layer>0:
				self.screen.blit(go.getSprite(),(go.getPos()[0]-offsetX,go.getPos()[1]-offsetY))
		
		self.objects.remove(self.Player)
		
		if self.isScaled:
			self.screen.update()
		pygame.display.update()



class BattleGraphicObject(object):
	def __init__(self,Animations,AnimationSpeed,State=0,new=False):
		self.animations = Animations
		self.animationSpeed = AnimationSpeed
		self.state=State
		self.frame=0
		self.effect=None
		self.effectVal=0
		self.new=new
		
		self.x=0
		self.y=0
	
	def getX(self):
		return self.x
	
	def getY(self):
		return self.y
	
	def setPos(self,pos):
		self.x=pos[0]
		self.y=pos[1]
	
	def getPos(self):
		return [self.x,self.y]
	
	def getWidth(self,dire):
		return self.getSprite(dire).get_width()
	
	def getHeight(self,dire):
		return self.getSprite(dire).get_height()
	
	def setState(self,state):
		self.state=state
		self.setFrame(0.0)
	
	def setFrame(self,frame):
		self.frame=frame
	
	def getSprite(self,dire):
		if self.effect==None:
			return self.animations[self.state][dire][int(self.frame)]
		elif self.effect=="Selected":
			ret = self.animations[self.state][dire][int(self.frame)].copy()
			ret.fill([abs(int(self.effectVal)),abs(int(self.effectVal)),abs(int(self.effectVal))],None,BLEND_ADD)
			return ret
		elif self.effect=="Selecting":
			ret = self.animations[self.state][dire][int(self.frame)].copy()
			ret.fill([0,0,0,int(self.effectVal)],None,BLEND_RGBA_SUB)
			return ret
	
	def getFrame(self):
		return self.frame
	
	def update(self,tick):
		self.frame+=(tick*1/self.animationSpeed[self.state])
		if self.frame>=len(self.animations[self.state][0]):
			self.frame=0
		
		if self.effect=="Selected":
			self.effectVal+=255*tick
			if self.effectVal>=127:
				self.effectVal=-127
			self.effect=None
		elif self.effect=="Selecting":
			if self.effectVal<=254:
				self.effectVal+=510*tick
			if self.effectVal>255:
				self.effectVal=255
	
	def scale(self,dire,scale):
		if self.new:
			return pygame.transform.scale(self.getSprite(dire),(int(self.getWidth(dire)*scale/2),int(self.getHeight(dire)*scale)/2))
		else:
			return pygame.transform.scale(self.getSprite(dire),(int(self.getWidth(dire)*scale),int(self.getHeight(dire)*scale)))
	
	def statusEffect(self,effect):
		self.effect=effect
	def statusReset(self):
		self.effect=None
		self.effectVal=0

class BattleGraphicsEngine(object):
	def __init__(self,screen,area,isScaled=False,fx=True):
		self.screen=screen
		self.isScaled=isScaled
		
		self.bg = pygame.image.load("Backgrounds/Battle/"+area+".png").convert()
		
		self.EnemyParty=[]
		self.PlayerParty=[]
		self.PPReverse=False
		self.EPReverse=False
		
		self.cameraRot=-90
		self.cameraZoom=.5
		self.y = 35
		
		self.infoWindow=False
		self.infoWindowY=240
		self.infoWindowData=[]
		
		self.statWindow=True
		self.statWindowX=-50
		self.statWindowData=[]
		
		self.turn=None
		
		self.menuSel=0
		self.menuSelX=0
		self.menuYMax=0
		self.menuXMax=0
		self.menu=None
		
		self.focus=None
		self.manualCamera=False
		self.cameraTarget=[35,45,1.5]			#[yPos,yRot,Time]
		self.cameraLastTarget=[35,0]	#[lastY,lastRot]
		
		self.text=[]
		self.compositor=BattleCompositor(self,fx)
	
	def addPlayer(self,playerGraphics,playerGame):
		self.PlayerParty.append(playerGraphics)
		self.statWindowData.append(playerGame)
	
	def addEnemy(self,enemy):
		self.EnemyParty.append(enemy)
	
	def rotate(self,rot):
		self.cameraRot=self.normalizeRotation(self.cameraRot+rot)
		self.setActorPositions()
	
	def normalizeRotation(self,rot):
		if rot>50:
			rot-=360
		if rot<-400:
			rot+=360
		return rot
	
	def moveY(self,y):
		self.y+=y
		self.setActorPositions()
	
	def zoom(self,amt):
		self.cameraZoom+=amt
		if self.cameraZoom<0:
			self.cameraZoom=0
	
	def zoomSet(self,zoom):
		self.cameraZoom=zoom
		if self.cameraZoom<0:
			self.cameraZoom=0
	
	def getRotation(self):
		return self.cameraRot
	
	def setRotation(self,rot):
		self.cameraRot = rot
		self.setActorPositions()
	
	def getCameraOffset(self):
		x = int((1280*self.cameraRot)/360)
		y = -self.y
		return [x,y]
	
	def toggleInfoWindow(self):
		self.infoWindow=not self.infoWindow
	
	def toggleStatWindow(self):
		self.statWindow=not self.statWindow
	
	def menuDown(self):
		if self.menuSel>=self.menuYMax:
			self.menuSel=0
		else:
			self.menuSel+=1
	
	def menuUp(self):
		if self.menuSel<=0:
			self.menuSel=self.menuYMax
		else:
			self.menuSel-=1
	
	def menuLeft(self):
		if self.menuSelX<=0:
			self.menuSelX=self.menuXMax
		else:
			self.menuSelX-=1
	
	def menuRight(self):
		if self.menuSelX>=self.menuXMax:
			self.menuSelX=0
		else:
			self.menuSelX+=1
	
	def menuAccept(self):
		if self.menu=="Main":
			if self.menuSel==0:
				self.menu="TargetE"
				self.menuXMax=len(self.EnemyParty)-1
				self.menuYMax=0
				self.cameraTarget=[35,90,1]
				self.infoWindow=False
			elif self.menuSel==1:
				self.menu="Magi"
			elif self.menuSel==2:
				self.menu="Item"
		elif self.menu=="TargetE":
			self.turn.setState(1)
			self.turn.setTime(0.0)
			
			for character in self.PlayerParty:
				character.statusReset()
			for character in self.EnemyParty:
				character.statusReset()
			
			self.turn=None
			self.menu=None
	
	def damage(self,Amount,PlayerTeam,PlayerIndex):
		if PlayerTeam:
			z=abs((math.sin(math.radians(self.cameraRot))/4)+1.5)
			self.text.append(TextObject(str(Amount),[147+math.cos(math.radians(self.cameraRot))*100,self.y*z+10]))
		else:
			z=abs((math.sin(math.radians(self.cameraRot-180))/4)+1.5)
			self.text.append(TextObject(str(Amount),[147+math.cos(math.radians(self.cameraRot-180))*100,self.y*z+10]))
	
	def autoCamera(self,tick):
		if self.cameraTarget==None:
			if self.menu==None or self.menu=="Main":
				self.rotate(10*tick)
				self.cameraLastTarget=[self.y,self.cameraRot]
		else:
			
			reset=0b00
			scalar=self.cameraRotationDir()
			if self.cameraTarget[0]>self.y:
				self.y+=(self.cameraTarget[0]-self.cameraLastTarget[0])*tick*self.cameraTarget[2]
				if self.cameraTarget[0]<=self.y:
					reset|=0b01
			else:
				self.y-=(self.cameraTarget[0]-self.cameraLastTarget[0])*tick*self.cameraTarget[2]
				if self.cameraTarget[0]>=self.y:
					reset|=0b01
			if not (self.normalizeRotation(self.cameraTarget[1])>self.cameraRot-1 and self.normalizeRotation(self.cameraTarget[1])<self.cameraRot+1):
				if (self.normalizeRotation(self.cameraTarget[1])>self.cameraRot-5 and self.normalizeRotation(self.cameraTarget[1])<self.cameraRot+5):
					self.rotate(scalar*(self.cameraTarget[1]-self.cameraLastTarget[1])*tick*self.cameraTarget[2]/5)
				else:
					self.rotate(scalar*(self.cameraTarget[1]-self.cameraLastTarget[1])*tick*self.cameraTarget[2])
				#print scalar
				if self.normalizeRotation(self.cameraTarget[1])>self.cameraRot-1 and self.normalizeRotation(self.cameraTarget[1])<self.cameraRot+1:
					reset|=0b10
			else:
				reset|=0b10
			if reset == 0b11:
				self.cameraLastTarget=[self.cameraTarget[0],self.cameraTarget[1]]
				self.cameraTarget=None
						
	def setActorPositions(self):
		reverse=False
		if self.cameraRot<-360 or (self.cameraRot>-170 and self.cameraRot<0):
			reverse=True
			
		if self.cameraTarget!=None:
			self.debug.setText(str(self.cameraRot)+","+str(self.normalizeRotation(self.cameraTarget[1])))
		else:
			self.debug.setText(str(self.cameraRot)+",None")
		
		PlayerXFactor=math.cos(math.radians(self.cameraRot))*125
		EnemyXFactor=math.cos(math.radians(self.cameraRot-180))*125
		Pz=abs((math.sin(math.radians(self.cameraRot))/4)+1.5)
		Pw=abs((-math.cos(math.radians(self.cameraRot*2))/2)+.5)
		Ez=abs((math.sin(math.radians(self.cameraRot-180))/4)+1.5)
		Ew=abs((-math.cos(math.radians(self.cameraRot*2))/2)+.5)
		
		#Player Team
		x=-(30*Pz*(len(self.PlayerParty)-1)*Pw)/2
		if reverse:
			if self.cameraRot<-90 and self.cameraRot<0 and self.cameraRot>-350:
				Pw*=-1
				x*=-1
				self.PPReverse=False
			else:
				self.PPReverse=True
		else:
			self.PPReverse=False
		for Character in self.PlayerParty:
			Character.setPos([122+PlayerXFactor+x,100+(-self.y*Pz)])
			x+=30*Pz*Pw
		
		#Enemy Team
		x=(30*Ez*(len(self.EnemyParty)-1)*Ew)/2
		if not reverse:
			Ew*=-1
		else:
			if self.cameraRot<-270 and self.cameraRot<-180:
				Ew*=-1
				x*=-1
			else:
				self.EPReverse=True
		for Character in self.EnemyParty:
			Character.setPos([122+EnemyXFactor+x,100+(-self.y*Ez)])
			x+=30*Ez*Ew
	
	def cameraRotationDir(self):
		target=self.normalizeRotation(self.cameraTarget[1])
		if target<self.cameraRot:
			pDist=target-(self.cameraRot-360)
			nDist=self.cameraRot-target
		else:
			pDist=target-self.cameraRot
			nDist=(self.cameraRot+360)-target
		
		if pDist>360:
			pDist-=360
		if nDist>360:
			nDist-=360
		
		#print pDist,nDist
		
		if pDist<=nDist:
			return 1
		else:
			return -1
		
	def update(self,tick):
		self.screen.fill((0,0,0))
		
		if not self.manualCamera:
			self.autoCamera(tick)
		
		offset=self.getCameraOffset()
		
		for player in self.PlayerParty:
			player.update(tick)
		
		for enemy in self.EnemyParty:
			enemy.update(tick)
		
		if self.menu!=None and self.menu.startswith("TargetE"):
			self.EnemyParty[len(self.EnemyParty)-1-self.menuSelX].statusEffect("Selected")
			for character in self.PlayerParty:
				character.statusEffect("Selecting")

		self.screen.blit(self.compositor.compBG(),[offset[0],offset[1]-250])
		if self.cameraRot>0:
			self.screen.blit(self.compositor.compBG(),[offset[0]-1280,offset[1]-250])
		if self.cameraRot<-100*360/(1280*self.cameraZoom):
			self.screen.blit(self.compositor.compBG(),[offset[0]+1280,offset[1]-250])
		
		#self.debug.setText(str(abs(self.cameraRot-22.5)/45))
		#self.debug.update(1)
		#self.screen.blit(self.debug.getSprite(),(0,0))
		#print self.cameraRot
		
		PlayerDir=0
		EnemyDir=4
		if self.cameraRot>23.5:
			PlayerDir=7
			EnemyDir=3
		elif self.cameraRot>-22.5:
			PlayerDir=6
			EnemyDir=2
		elif self.cameraRot>-67.5:
			PlayerDir=5
			EnemyDir=1
		elif self.cameraRot>-112.5:
			PlayerDir=4
			EnemyDir=0
		elif self.cameraRot>-157.5:
			PlayerDir=3
			EnemyDir=7
		elif self.cameraRot>-202.5:
			PlayerDir=2
			EnemyDir=6
		elif self.cameraRot>-247.5:
			PlayerDir=1
			EnemyDir=5
		elif self.cameraRot>-292.5:
			PlayerDir=0
			EnemyDir=4
		elif self.cameraRot>-337.5:
			PlayerDir=7
			EnemyDir=3
		elif self.cameraRot>-382.5:
			PlayerDir=6
			EnemyDir=2
		elif self.cameraRot>-427.5:
			PlayerDir=5
			EnemyDir=1
		
		Pz=abs((math.sin(math.radians(self.cameraRot))/4)+1.5)
		Ez=abs((math.sin(math.radians(self.cameraRot-180))/4)+1.5)
		
		orderedPP=self.PlayerParty
		if self.PPReverse:
			orderedPP=reversed(self.PlayerParty)

		orderedEP=self.EnemyParty
		if self.EPReverse:
			orderedEP=reversed(self.EnemyParty)
		
		if (self.cameraRot>-180 and self.cameraRot<0) or self.cameraRot<-360:
			for Character in orderedPP:
				self.screen.blit(Character.scale(PlayerDir,Pz),Character.getPos())
			for Character in orderedEP:
				self.screen.blit(Character.scale(EnemyDir,Ez),Character.getPos())
		else:
			for Character in orderedEP:
				self.screen.blit(Character.scale(EnemyDir,Ez),Character.getPos())
			for Character in orderedPP:
				self.screen.blit(Character.scale(PlayerDir,Pz),Character.getPos())
		
		#GUI
		if self.infoWindow and self.infoWindowY>200:
			self.infoWindowY-=tick*160
		if not self.infoWindow and self.infoWindowY<240:
			self.infoWindowY+=tick*160
		self.screen.fill((0,0,255),[2,int(self.infoWindowY),316,40])
		
		if self.statWindow and self.statWindowX<5:
			self.statWindowX+=tick*160*len(self.PlayerParty)
		if not self.statWindow and self.statWindowX>-52*len(self.PlayerParty):
			self.statWindowX-=tick*160*len(self.PlayerParty)
		for i in range(len(self.PlayerParty)):
			self.screen.fill((0,0,255),[i*52+int(self.statWindowX),5,50,31])
			self.screen.fill((64,64,64),[i*52+int(self.statWindowX)+2,8,1,3])
			self.screen.fill((64,64,64),[i*52+int(self.statWindowX)+48,8,1,3])
			self.screen.fill((127,127,127),[i*52+int(self.statWindowX)+3,8,int(self.statWindowData[i].getTime()*45),3])
			self.screen.blit(font.render(self.statWindowData[i].getName(),False,(255,255,255)),[i*52+int(self.statWindowX)+2,5])
			self.screen.blit(font.render("HP:"+str(self.statWindowData[i].getHP())+"/"+str(self.statWindowData[i].getHPM()),False,(255,255,255)),[i*52+int(self.statWindowX)+2,15])
			self.screen.fill((127,0,0),[i*52+int(self.statWindowX)+2,23,46,1])
			self.screen.fill((255,0,0),[i*52+int(self.statWindowX)+3,23,int((float(self.statWindowData[i].getHP())/self.statWindowData[i].getHPM())*44),1])
			self.screen.blit(font.render("MP:"+str(self.statWindowData[i].getMP())+"/"+str(self.statWindowData[i].getMPM()),False,(255,255,255)),[i*52+int(self.statWindowX)+2,25])
			self.screen.fill((0,127,0),[i*52+int(self.statWindowX)+2,33,46,1])
			if self.statWindowData[i].getMPM()>0:
				self.screen.fill((0,255,0),[i*52+int(self.statWindowX)+3,33,int((float(self.statWindowData[i].getMP())/self.statWindowData[i].getMPM())*44),1])
		
		if self.turn == None:
			for player in self.statWindowData:
				if player.getTime()>=1:
					self.turn = player
					self.infoWindow=True
					self.menu = "Main"
					self.menuXMax=0
					self.menuYMax=2
		else:
			gui.battleGui(self.screen,self.turn,self.menu,self.menuSel,self.infoWindowY)
		
		for text in self.text:
			pos=text.getPos()
			self.screen.blit(text.getSprite(),pos)
			text.setPos([pos[0],pos[1]+tick*-10])
		
		self.debug.update(1)
		self.screen.blit(self.debug.getSprite(),(0,0))
		
		if self.isScaled:
			self.screen.update()
		pygame.display.update()

class BattleCompositor(object):
	def __init__(self,parent,comp=True,bgMult=[255,255,255],enemyMult=[255,255,255]):
		self.parent=parent
		self.bgMult=bgMult
		self.enemyMult=enemyMult
		self.comp=comp
	
	def compBG(self):
		if not self.comp and self.bgMult!=[255,255,255]:
			return self.parent.bg
		ret = self.parent.bg.copy()
		ret.fill(self.bgMult,special_flags=BLEND_MULT)
		return ret
	
	def setBG(self,bg):
		self.bgMult=bg
	def getBG(self):
		return self.bgMult
	
	def compEnemy(self,img,isTarget):
		if not self.comp or not isTarget:
			return img
		ret = img.copy()
		ret.fill(self.enemyMult,special_flags=BLEND_MULT)
		return ret
	
	def setEnemy(self,enemy):
		self.enemyMult=enemy
	def getEnemy(self):
		return self.enemyMult
